#!/usr/bin/python# Caleb Piekstra and Sara Perkins# CS 423, Lab 5# fall 2015##################################################################### convertFileToSequence - takes a FASTA file and returns the# sequence as a string#####################################################################def convertFileToSequence(filename):    # read in file    file = open(filename)    # read in first line    header = file.readline()    if (header[0] == '>'):        print("in FASTA format")    else:        print("invalid format")        file.close()        return      # read in rest of file    sequence = file.read()        # close file    file.close()    # remove all return and newline characters    sequence = sequence.replace("\r", "")    sequence = sequence.replace("\n", "")    return sequence####################################################################### localAlignmentScore - Determines the score of the optimal local # alignment of two strings######################################################################def localAlignmentScore(s1, s2, filename=None):     # add a blank string as padding     s1 = ' ' + s1     s2 = ' ' + s2          # Scoring system     MATCH = 5     MISMATCH = -4     GAP = -6     # Max value of alignment found     maxValue = 0          # To keep track of the location of the maximum alignment     maxRowPos = 0          maxColPos = 0     # set table size     NUM_ROWS = len(s2)     NUM_COLS = len(s1)     # Create table and fill it with zeros     c = createTable(NUM_ROWS, NUM_COLS, 0)     # Creates table for getting back the optimal alignment, fill table with "F"     # uses "D", "L", and "T" for diagonal, left, and top     d = createTable(NUM_ROWS, NUM_COLS, "F")     # The above automatically sets the gap penalties in left column and top row          # implements dynamic programming algorithm for local alignment     # fills in entries in cost table and direction table          # update table to show alignment penalties     for i in range(1, NUM_ROWS):          for j in range(1, NUM_COLS):               # set value of match/mismatch               m = MATCH if s1[j] == s2[i] else MISMATCH               # calculate costs based on direction               left = c[i][j-1] + GAP               top = c[i-1][j] + GAP               diag = c[i-1][j-1] + m               # set cost               cost = max(0, left,top,diag)               c[i][j] = cost               # set direction based on cost               # Precedence: F > D > T > L                              if cost == 0:                    d[i][j] = "F"               elif cost == diag:                    d[i][j] = "D"               elif cost == top:                    d[i][j] = "T"               else:                    d[i][j] = "L"               # update max value and its position               if cost > maxValue:                    maxValue = cost                    maxRowPos = i                    maxColPos = j               ##     # Prints out table (only useful for small tables - used for debugging)##     # Commented out, satisfied that the algorithm is working##     printTable(c, "costs.txt")##     printTable(d, "directions.txt")     # find optimal alignment     # if filename:        # align(d, s1, s2, maxRowPos, maxColPos, filename)     # else:        # align(d, s1, s2, maxRowPos, maxColPos, "alignment.txt")     # return optimal score (lower right-hand cell in table]     return c[maxRowPos][maxColPos]##################################################################### Creates a 2D table with the given number of rows and columns# and fills all entries with value given as a parameter# (function completed by Tammy VanDeGrift)####################################################################def createTable(numRows, numCols, value):     table = []     row = 0     # create 2D table initialized with value     while (row < numRows):          table.append([])          col = 0          while (col < numCols):               table[row].append(value)               col = col + 1          row = row + 1     return table################################################################### Prints 2D table to file (only useful for small tables for short# strings), can be used for integer as well as char values# tabs between the values on each row# Useful function for debugging purposes only##################################################################def printTable(table, filename):     NUM_ROWS = len(table)     NUM_COLS = len(table[0])     # write table to output file, one row at a time     with open(filename, 'w') as out:          for i in range(0, NUM_ROWS):               row = ""               for j in range(0, NUM_COLS):                    row += str(table[i][j]) + '\t'               out.write(row+'\n')     return################################################################# Reconstructs the optimal alignment and prints the alignment# to a file. Because the sequences can be long, prints the# alignment 50 characters on one line, the other string of 50 characters# on the next line, and then skips one line, as follows:# AATT--GGCTATGCT--C-G-TTACGCA-TTACT-AA-TCCGGTC-AGGC# AAATATGG---TGCTGGCTGCTT---CAGTTA-TGAACTCC---CCAGGC## TATGGGTGCTATGCTCG--T--TACG-CA# TCAT--TGG---TGCTGGCTGCTT--ACA## direction is a 2D table, s1 and s2 are the original DNA# sequences to align, maxRow and maxCol are the position of the# max score in the local alignment table and filename is the# name of the output file###############################################################def align(direction, s1, s2, maxRow, maxCol, filename):     # initialize rows, columnss, and newly aligned sequences     alignS1 = ""     alignS2 = ""     # evalutate table for all valid indices     while(maxRow >= 0 and maxCol >= 0):          d = direction[maxRow][maxCol] # start with bottom right          # diagonal          if d == "D":               alignS1 = s1[maxCol] + alignS1               alignS2 = s2[maxRow] + alignS2               maxRow -= 1               maxCol -= 1          # top          elif d == "T":               alignS1 = "-" + alignS1               alignS2 = s2[maxRow] + alignS2               maxRow -= 1          # left          elif d == "L":               alignS1 = s1[maxCol] + alignS1               alignS2 = "-" + alignS2               maxCol -= 1          # first, "F"          else:               break     # print the strings to the output file, 50 characters at a time     with open(filename, 'w') as out:          for i in range(0, len(alignS1), 50):               out.write("%s\n%s\n\n" % (alignS1[i:i+50], alignS2[i:i+50]))     return### End of functions ######################################################################################### Testing ##########################################################################################if __name__ == "__main__":    ## Calculate local alignment score of two sequences    #s = "AGCGTCTA"    #t = "TGCATCTCG"    ## longer test, from lab sheet    #s = "ATGTTGAAGTCAGCCGTTTATTCAATTTTAGCCGCTTCTTTGGTTAATGCAGGTACCATACCCCTCGGAAAGTTATCTGACATTGACAAAATCGGAACTCAAACGGAAATTTTCCCATTTTTGGGTGGTTCTGGGCC"    #t = "ATGTTTTCCCGCAGTCGCTGTGGTTCACTTGTAACAAGTGTGGCTCGCAAAATGTGGAACCACCCAAGCCAGCGCTGGCTCATCTTGATCTGCGTTATATGTTTGCTGTCTTTTGCGCTGGCC"    #s = "AATTGGCTATGCTCGTTACGCATTACTAATCCGGTCAGGCTATGGGTGCTATGCTCGTTACGCA"    #t = "AAATATGGTGCTGGCTGCTTCAGTTATGAACTCCCCAGGCTCATTGGTGCTGGCTGCTTACA"        #s = "TATGCT"    #t = "TGACAGT"        #s = "TGGTAGATTCCCACGAGATCTACCGAGTATGAGTAGGGGGACGTTCGCTCGG"    #t = "GCCTCTAACACACTGCACGAGATCAACCGAGATATGAGTAATACAGCGGTACGGG"        s = convertFileToSequence("yeast_random.txt")    t = convertFileToSequence("fruit_fly_random.txt")    #t = convertFileToSequence("flyPHO12.txt")    optimalScore = localAlignmentScore(s, t, "PHO12_local_alignment.txt")    print(s)    print(t)    print("Local alignment score: " + str(optimalScore))